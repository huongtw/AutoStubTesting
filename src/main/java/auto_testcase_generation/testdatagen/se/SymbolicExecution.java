package auto_testcase_generation.testdatagen.se;

import auto_testcase_generation.cfg.ICFG;
import auto_testcase_generation.cfg.object.*;
import auto_testcase_generation.cfg.testpath.ITestpathInCFG;
import auto_testcase_generation.testdatagen.SymbolicExecutionTestdataGeneration;
import auto_testcase_generation.testdatagen.se.memory.array.ArraySymbolicVariable;
import auto_testcase_generation.testdatagen.se.memory.pointer.PointerSymbolicVariable;
import auto_testcase_generation.testdatagen.se.normalization.ConstraintNormalizer;
import auto_testcase_generation.testdatagen.AbstractAutomatedTestdataGeneration;
import auto_testcase_generation.testdatagen.se.memory.*;
import auto_testcase_generation.testdatagen.se.memory.basic.BasicSymbolicVariable;
import auto_testcase_generation.testdatagen.se.normalstatementparser.*;
import auto_testcase_generation.utils.ASTUtils;
import com.dse.config.IFunctionConfig;
import com.dse.environment.Environment;
import com.dse.logger.AkaLogger;
import com.dse.parser.dependency.Dependency;
import com.dse.parser.dependency.FunctionCallDependency;
import com.dse.parser.dependency.SizeOfArrayDepencencyGeneration;
import com.dse.parser.dependency.SizeOfArrayOrPointerDependency;
import com.dse.parser.dependency.finder.Level;
import com.dse.parser.dependency.finder.VariableSearchingSpace;
import com.dse.parser.object.*;
import com.dse.search.Search;
import com.dse.search.condition.EnumNodeCondition;
import com.dse.search.condition.MacroDefinitionNodeCondition;
import com.dse.search.condition.MacroFunctionNodeCondition;
import com.dse.util.IRegex;
import com.dse.util.SpecialCharacter;
import com.dse.util.Utils;
import com.dse.util.VariableTypeUtils;
import org.eclipse.cdt.core.dom.ast.*;
import org.eclipse.cdt.core.dom.ast.cpp.*;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTIdExpression;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class SymbolicExecution implements ISymbolicExecution {

    private final static AkaLogger logger = AkaLogger.get(SymbolicExecution.class);

    protected ICommonFunctionNode functionNode;

    /**
     * Represent a test path generated from control flow graph
     */
    protected ITestpathInCFG testpath = null;

    /**
     * The variable passing to the function
     */
    private Parameters parameters = null;

    /**
     * Table of variables
     */
    private VariableNodeTable tableMapping = new VariableNodeTable();

    /**
     * Store path constraints generated by performing symbolic execution the
     * given test path
     */
    protected PathConstraints constraints = new PathConstraints();

    /**
     * The return value of a test path, specified by "return ..."
     */
    private String returnValue = "";

    private Set<NewVariableInSe> newVariables = new HashSet<>();

    private final FunctionCallTable callTable = new FunctionCallTable();

    private List<String> parameterNames = new ArrayList<>();

    List <Node> listStubNode = new ArrayList<>();

    private String newAstString = "";

    public SymbolicExecution(ITestpathInCFG testpath, Parameters parameters, ICommonFunctionNode functionNode)
            throws Exception {

        if (functionNode != null && parameters != null && parameters.size() > 0 && testpath != null) {
            Date startTime = Calendar.getInstance().getTime();

            this.testpath = testpath;
            this.parameters = parameters;
            for(IVariableNode node : parameters){
                parameterNames.add(node.getName());
            }
            this.functionNode = functionNode;
            listStubNode = this.functionNode.getParent().getChildren();

            tableMapping.setFunctionNode(this.functionNode);
            createMappingTable(parameters);

            SE(testpath.getAllCfgNodes());

            Date end = Calendar.getInstance().getTime();
            AbstractAutomatedTestdataGeneration.symbolicExecutionTime += end.getTime() - startTime.getTime();
        }
    }

    private void SE(List<ICfgNode> cfgNodes) {
        int scopeLevel = 1;
        int count = 0;


        // STEP 2.
        // We perform the symbolic execution on all of the statements in the
        // normalized
        // test path until catch an supported statement.
        handle(cfgNodes, scopeLevel, count);

        this.constraints.setVariablesTableNode(this.tableMapping);
    }

    private ICommonFunctionNode context;

    private void handle(List<ICfgNode> cfgNodes, int scopeLevel, int count) {

        context = functionNode;
        ICommonFunctionNode prevContext = null;

        for (ICfgNode cfgNode : cfgNodes) {
            int a =0;
            // If the test path is always false, we stop the symbolic execution.
            if (!this.constraints.isAlwaysFalse())
                try {
                    if (cfgNode instanceof BeginFunctionCallFlagCfgNode) {
                        BeginFunctionCallFlagCfgNode begin = (BeginFunctionCallFlagCfgNode) cfgNode;

                        logger.debug("Step into \"" + begin.getFunction().getName() + "\"");

                        // update context
                        prevContext = context;
                        context = begin.getFunction();

                        visitFunctionCall(begin, scopeLevel);

                    } else if (cfgNode instanceof EndFunctionCallFlagCfgNode) {
                        EndFunctionCallFlagCfgNode end = (EndFunctionCallFlagCfgNode) cfgNode;
                        logger.debug("Step over \"" + end.getFunction().getName() + "\"");

                        scopeLevel = exitFunctionCall(end, scopeLevel);

                        context = prevContext;

                    } else if (cfgNode instanceof BeginFlagCfgNode || cfgNode instanceof EndFlagCfgNode) {
                        // nothing to do
                    } else {

                        logger.debug("Handle \"" + cfgNode.getContent() + "\"");
                        AbstractAutomatedTestdataGeneration.numOfSymbolicStatements++;
                        boolean isContinue = true;

                        if (cfgNode instanceof NormalCfgNode) {
                            newAstString ="";
                            IASTNode ast = ((NormalCfgNode) cfgNode).getAst();
                            //Replace stub function ast by its stub-name
                            collectStubVar(ast);
                            String name = ast.getRawSignature();
                            String content = "";
                            boolean containStub = false;
                            if(newAstString != ""){
                                IASTNode newAst = Utils.convertToIAST(newAstString);
                                content = ExpressionRewriterUtils.rewriteMacro(functionNode, newAst.getRawSignature());
                                containStub = true;
                            }
                            else {
                                content = ExpressionRewriterUtils.rewriteMacro(functionNode, ast.getRawSignature());
                            }
                            IASTNode normalizedAST = Utils.convertToIAST(content);
                            switch (getTypeOfStatement(cfgNode, normalizedAST)) {
                                case NAMESPACE:
                                    logger.debug("is NAMESPACE");
                                    new UsingNamespaceParser().parse(normalizedAST, tableMapping, callTable);
                                    break;

                                case UNARY_ASSIGNMENT: {
                                    logger.debug("is UNARY_ASSIGNMENT");
                                    addNewVariablesAndConstraints(normalizedAST, this.newVariables, constraints);
                                    new UnaryBinaryParser().parse(normalizedAST, tableMapping, callTable);
                                    break;
                                }
                                case BINARY_ASSIGNMENT: {
                                    logger.debug("is BINARY_ASSIGNMENT");
                                    addNewVariablesAndConstraints(normalizedAST, this.newVariables, constraints);
                                    new BinaryAssignmentParser().parse(normalizedAST, tableMapping, callTable);
                                    break;
                                }

                                case DECLARATION: {
                                    logger.debug("is DECLARATION");
                                    addNewVariablesAndConstraints(normalizedAST, this.newVariables, constraints);
                                    isContinue = this.parseDeclaration(normalizedAST, scopeLevel, tableMapping, functionNode);
                                    break;
                                }

                                case CONDITION: {
                                    logger.debug("is CONDITION");
//                                    if (!cfgNode.equals(cfgNodes.get(cfgNodes.size()-1))){
                                    if (cfgNode instanceof DefaultCaseCfgNode) {
                                        addNewVariablesAndConstraintsForDefault((DefaultCaseCfgNode) cfgNode, this.newVariables, constraints);
                                    } else {
                                        addNewVariablesAndConstraints(normalizedAST, this.newVariables, constraints);
                                    }
                                    isContinue = this.parseCondition(cfgNode, normalizedAST, count, tableMapping, containStub);
//                                    }
                                    break;
                                }

                                case RETURN: {
                                    IASTNode astReturn = ((IASTReturnStatement) ((NormalCfgNode) cfgNode).getAst()).getReturnValue();
                                    addNewVariablesAndConstraints(astReturn, this.newVariables, constraints);

                                    if (cfgNode.getTrueNode() instanceof EndFunctionCallFlagCfgNode) {
                                        EndFunctionCallFlagCfgNode end = (EndFunctionCallFlagCfgNode) cfgNode.getTrueNode();
                                        returnFunctionCall((NormalCfgNode) cfgNode, end);
                                    }

                                    break;
                                }

                                case THROW: {
                                    logger.debug("is THROW");
                                    ThrowParser throwParser = new ThrowParser();
                                    throwParser.parse(normalizedAST, tableMapping, callTable);
                                    this.returnValue = throwParser.getExceptionName();
                                    break;
                                }

                                case IGNORE:
                                    logger.debug("is IGNORE");
                                    break;

                                case UNSPECIFIED_STATEMENT:
                                    logger.debug("is UNSPECIFIED_STATEMENT");
                                    break;
                            }
                        } else if (cfgNode instanceof ScopeCfgNode) {
                            logger.debug("is ScopeCfgNode");
                            scopeLevel = this.parseScope(cfgNode, scopeLevel, tableMapping);

                        } else if (cfgNode instanceof FlagCfgNode) {
                            // nothing to do
                        } else
                            break;

                        Utils.containFunction = false;
                        count++;

                        if (!isContinue)
                            break;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    break;
                }
        }
    }

    private void returnFunctionCall(NormalCfgNode cfgNode, EndFunctionCallFlagCfgNode end) throws Exception {
        IASTFunctionCallExpression expr = end.getExpr();
        String varName = callTable.get(expr);

        /*
         * STEP 1: assign return variable
         */
        IASTReturnStatement astReturn = (IASTReturnStatement) cfgNode.getAst();
        String returnVal = astReturn.getReturnValue().getRawSignature();

        IASTBinaryExpression ast = ASTUtils.generateBinaryExpression("=", varName, returnVal);
        addNewVariablesAndConstraints(ast, this.newVariables, constraints);
        new BinaryAssignmentParser().parse(ast, tableMapping, callTable);
    }

    private int exitFunctionCall(EndFunctionCallFlagCfgNode end, int scopeLevel) {
        IASTFunctionCallExpression expr = end.getExpr();
        IASTInitializerClause[] arguments = expr.getArguments();

        List<IVariableNode> parameters = end.getFunction().getArguments();

        for (int i = 0; i < arguments.length; i++) {
            String name = parameters.get(i).getName();
            ISymbolicVariable paramVar = tableMapping.findorCreateVariableByName(name);

            IASTInitializerClause argumentAST = arguments[i];

            // update argument variable
            // case: pointer, array
            // TODO: reference variable (Ex: &var)
            if (argumentAST instanceof ICPPASTFieldReference
                    || argumentAST instanceof ICPPASTArraySubscriptExpression
                    || argumentAST instanceof CPPASTIdExpression
            ) {
                if (paramVar instanceof ArraySymbolicVariable || paramVar instanceof PointerSymbolicVariable) {
                    String argument = argumentAST.getRawSignature();
                    ISymbolicVariable argumentVar = tableMapping.findorCreateVariableByName(argument);

                    if (argumentVar == paramVar) {
                        List<ISymbolicVariable> allMatches = tableMapping.findVariablesByName(argument);
                        for (ISymbolicVariable var : allMatches) {
                            if (!var.equals(paramVar)) {
                                argumentVar = var;
                                break;
                            }
                        }
                    }

                    argumentVar.assign(paramVar);
                }
            }
        }

        return parseScope(end, scopeLevel, tableMapping);
    }

    private void visitFunctionCall(BeginFunctionCallFlagCfgNode begin, int scopeLevel) throws Exception {
        IFunctionNode called = begin.getFunction();
        String returnType = called.getReturnType();

        /*
         * STEP 1: add return symbolic variable
         */
        if (!VariableTypeUtils.isVoid(returnType)) {
            String name = callTable.put(begin.getExpr());

            IASTDeclarationStatement ast = ASTUtils.generateDeclarationStatement(returnType, name);
            addNewVariablesAndConstraints(ast, this.newVariables, constraints);
            parseDeclaration(ast, scopeLevel, tableMapping, functionNode);
        }

        /*
         * STEP 2: add parameter symbolic variable
         */
        IASTInitializerClause[] arguments = begin.getExpr().getArguments();
        List<IVariableNode> parameters = called.getArguments();
        for (int i = 0; i < arguments.length; i++) {
            String type = parameters.get(i).getRealType();
            String name = parameters.get(i).getName();
            String value = arguments[i].getRawSignature();
            int varScope = scopeLevel + 1;

            // argument and parameter have difference name
            if (!value.equals(name)) {
                IASTDeclarationStatement ast = ASTUtils.generateDeclarationStatement(type, name, value);
                addNewVariablesAndConstraints(ast, this.newVariables, constraints);
                parseDeclaration(ast, varScope, tableMapping, called);
            }
            // have same name
            else {
                ISymbolicVariable argumentVar = tableMapping.findorCreateVariableByName(name);

                INode nodeType = parameters.get(i).resolveCoreType();
                String defaultVal = nodeType instanceof StructureNode ? name : "0";
                IFunctionConfig functionConfig = functionNode.getFunctionConfig();

                ISymbolicVariable v = SymbolicVariable.create(name, type, nodeType,
                        defaultVal, varScope, functionConfig);

                if (v != null) {
                    v.assign(argumentVar);
                    tableMapping.add(v);
                }
            }
        }
    }

    private void addNewVariablesAndConstraintsForDefault(CfgNode node, Set<NewVariableInSe> newVariables, PathConstraints constraints) {
        String content = node.getContent();
        IASTNode astNode = Utils.convertToIAST(content);
        addNewVariablesAndConstraints(astNode, newVariables, constraints);
    }

    private String rewriteForAddNewVariable(String expr) throws Exception {
        String newExpr = ExpressionRewriterUtils.rewrite(tableMapping, expr);
        newExpr = newExpr.replace(ISymbolicVariable.PREFIX_SYMBOLIC_VALUE, "")
                .replace(ISymbolicVariable.SEPARATOR_BETWEEN_STRUCTURE_NAME_AND_ITS_ATTRIBUTES, ".")
                .replace(ISymbolicVariable.ARRAY_CLOSING, "]")
                .replace(ISymbolicVariable.ARRAY_OPENING, "[");
        return newExpr;
    }

    private void addNewVariablesAndConstraints(IASTNode node, Set<NewVariableInSe> newVariables, PathConstraints constraints) {
        IASTNode newNode = node;
        try {
            String newExpr = rewriteForAddNewVariable(node.getRawSignature());
            newNode = Utils.convertToIAST(newExpr);
        } catch (Exception e) {
            logger.error("Cannot rewrite " + node.getRawSignature());
            e.printStackTrace();
        }

        List<IASTFieldReference> fieldReferences = ASTUtils.getFieldReferences(newNode);
        for (IASTFieldReference fieldReference : fieldReferences) {
            addNewVariablesAndConstraintsFromFieldRef(fieldReference, newVariables, constraints);
        }

        List<IASTUnaryExpression> starExprs = ASTUtils.getStarExpressions(newNode);
        for (IASTUnaryExpression starExpr : starExprs) {
            addNewVariablesAndConstraintsFromStarExpr(starExpr, newVariables, constraints);
        }

        List<IASTArraySubscriptExpression> arraySubscripts = ASTUtils.getArraySubscriptExpression(newNode);
        for (IASTArraySubscriptExpression arraySubscript : arraySubscripts) {
            IASTExpression expr = arraySubscript;
            do {
                addNewVariablesAndConstraintsFromArrayExpr(arraySubscript, newVariables, constraints);
                expr = ((IASTArraySubscriptExpression) expr).getArrayExpression();
            } while (expr instanceof IASTArraySubscriptExpression);
        }
    }

    private void addNewVariablesAndConstraintsFromFieldRef(IASTFieldReference fieldReference, Set<NewVariableInSe> newVariables, PathConstraints constraints) {
        // Ex: field ref = "trie[0].root_node"
        // new var = "trie"
        String owner = fieldReference.getFieldOwner().getRawSignature();
        try {
            owner = rewriteForAddNewVariable(owner);
        } catch (Exception e) {
            logger.error("Cannot rewrite " + owner);
            e.printStackTrace();
        }

        newVariables.add(new NewVariableInSe(owner, owner));

        // new var = "trie[0].root_node"
        String fullNameVar;
        if (fieldReference.isPointerDereference())
            fullNameVar = owner + "[0]." + fieldReference.getFieldName().getRawSignature();
        else
            fullNameVar = owner + "." + fieldReference.getFieldName().getRawSignature();

        String normalizedFullName = VariableNodeTable.normalizeNameOfVariable(fullNameVar);
        newVariables.add(new NewVariableInSe(fullNameVar, normalizedFullName));

        // new var = "trie[0]"
        if (fieldReference.isPointerDereference()) {
            String dereferencedVar = owner + "[0]";
            String normalizedDereference = VariableNodeTable.normalizeNameOfVariable(dereferencedVar);
            newVariables.add(new NewVariableInSe(dereferencedVar, normalizedDereference));
        }

        // add new constraint
        // pc: trie->attr -> trie != NULL
        if (fieldReference.isPointerDereference())
            constraints.add(new PathConstraint(owner + "!=NULL", null, PathConstraint.CREATE_FROM_DECISION));
    }

    private void addNewVariablesAndConstraintsFromStarExpr(IASTUnaryExpression starExpr, Set<NewVariableInSe> newVariables, PathConstraints constraints) {
        IASTExpression operand = starExpr.getOperand();
        if (operand instanceof IASTFieldReference) {
            IASTFieldReference fRChild = (IASTFieldReference) operand;
            String owner = fRChild.getFieldOwner().getRawSignature();
            try {
                owner = rewriteForAddNewVariable(owner);
            } catch (Exception e) {
                logger.error("Cannot rewrite " + owner);
                e.printStackTrace();
            }

            String fullNameVar;
            if (fRChild.isPointerDereference())
                fullNameVar = owner + "[0]." + (fRChild).getFieldName().getRawSignature();
            else
                fullNameVar = owner + "." + fRChild.getFieldName().getRawSignature();

            fullNameVar = VariableNodeTable.normalizeNameOfVariable(fullNameVar);
            constraints.add(new PathConstraint(fullNameVar + "!=NULL", null, PathConstraint.CREATE_FROM_DECISION));
        } else {
            String pointerVar = operand.getRawSignature();
            try {
                pointerVar = rewriteForAddNewVariable(pointerVar);
            } catch (Exception e) {
                logger.error("Cannot rewrite " + pointerVar);
                e.printStackTrace();
            }

            String dereferencedVar = pointerVar + "[0]";
            String normalizedDereference = VariableNodeTable.normalizeNameOfVariable(dereferencedVar);
            newVariables.add(new NewVariableInSe(dereferencedVar, normalizedDereference));
            String normalizedPointerVar = VariableNodeTable.normalizeNameOfVariable(pointerVar);
            constraints.add(new PathConstraint(normalizedPointerVar + "!=NULL", null, PathConstraint.CREATE_FROM_DECISION));
        }
    }

    private void addNewVariablesAndConstraintsFromArrayExpr(IASTArraySubscriptExpression arraySubscript, Set<NewVariableInSe> newVariables, PathConstraints constraints) {
        String arrayName = arraySubscript.getArrayExpression().getRawSignature();
        try {
            arrayName = rewriteForAddNewVariable(arrayName);
        } catch (Exception e) {
            logger.error("Cannot rewrite " + arrayName);
            e.printStackTrace();
        }

        String normalizedArrayName = VariableNodeTable.normalizeNameOfVariable(arrayName);
        newVariables.add(new NewVariableInSe(arrayName, normalizedArrayName));
        constraints.add(new PathConstraint(normalizedArrayName + "!=NULL", null, PathConstraint.CREATE_FROM_DECISION));

        String index = arraySubscript.getArgument().getRawSignature();
        String fullName = arrayName + "[" + index + "]";

        constraints.add(new PathConstraint(index + " >= 0", null, PathConstraint.CREATE_FROM_DECISION));
        constraints.add(new PathConstraint(arrayName + " > " + index, null, PathConstraint.CREATE_FROM_DECISION));

        try {
            fullName = rewriteForAddNewVariable(fullName);
        } catch (Exception e) {
            logger.error("Cannot rewrite " + fullName);
            e.printStackTrace();
        }

        String normalizedFullName = VariableNodeTable.normalizeNameOfVariable(fullName);
        newVariables.add(new NewVariableInSe(fullName, normalizedFullName));
    }

    /**
     * In order to trace the changes of variables, we create a table of
     * variables that stores its values.
     * <p>
     * For example, we have a table: (x, int, 2). The value of x is equivalent
     * to 2. After an increasing statement (i.g., x++), the table becomes (x,
     * int, 3)
     *
     * @param parameters
     * @throws Exception
     */
    private void createMappingTable(Parameters parameters) throws Exception {
        for (INode parameter : parameters)
            if (parameter instanceof VariableNode) {

                // All passing variables have global access
                VariableNode par = (VariableNode) parameter;

                INode nodeType = par.resolveCoreType();

                String name = par.getName();
                if (name == null || name.isEmpty())
                    continue;

                String defaultValue = ISymbolicVariable.PREFIX_SYMBOLIC_VALUE + name;
                // update default value for const global variable
                if (par instanceof ExternalVariableNode && par.isConst()) {
                    defaultValue = par.getDefaultValue();
                }

                String realType = par.getRealType();
                if (realType == null || realType.length() == 0)
                    continue;

                IFunctionConfig functionConfig = functionNode.getFunctionConfig();

                SymbolicVariable v = SymbolicVariable.create(name, realType, nodeType, defaultValue,
                        ISymbolicVariable.GLOBAL_SCOPE, functionConfig);

                if (v != null) {
                    v.setFunction(functionNode);
                    this.tableMapping.add(v);
                    v.setNode(nodeType);
                }
            }
    }

    /**
     * Get the type of the statement.
     * <p>
     * In this function, we define some rules to detect the type of the
     * statements exactly.
     *
     * @param stm
     * @return
     */
    private int getTypeOfStatement(ICfgNode cfgNode, IASTNode stm) {
        if (cfgNode instanceof SwitchCfgNode)
            return ISymbolicExecution.IGNORE;

        else if (cfgNode instanceof ConditionCfgNode || cfgNode instanceof CaseCfgNode)
            return ISymbolicExecution.CONDITION;

        else if (cfgNode instanceof ReturnNode)
            return ISymbolicExecution.RETURN;

        stm = Utils.shortenAstNode(stm);

        if (stm.getRawSignature().startsWith(ISymbolicExecution.NAMESPACE_SIGNAL))
            return ISymbolicExecution.NAMESPACE;

//        else if (stm instanceof ICPPASTBinaryExpression && ASTUtils.isCondition((ICPPASTBinaryExpression) stm)
//                || stm instanceof IASTDefaultStatement
//                || stm.getRawSignature().startsWith("!") /* Ex: !(a>0) */
//                || stm.getRawSignature().matches(IRegex.NAME_REGEX)/* Ex: a */)
//            return ISymbolicExecution.CONDITION;

        else if (stm instanceof ICPPASTUnaryExpression)
            return ISymbolicExecution.UNARY_ASSIGNMENT;

        else if (stm instanceof IASTExpressionStatement) {
            /*
             * In case the statement is expression (e.g., binary expression,
             * unary expression)
             */
            IASTExpression _stm = ((IASTExpressionStatement) stm).getExpression();

            if (_stm instanceof IASTBinaryExpression)
                if (_stm.getRawSignature().contains("="))
                    /*
                     * If the statement is binary expression and it contains
                     * "=", it means that the statement is binary assignment.
                     *
                     * For example: x=2*x
                     */
                    return ISymbolicExecution.BINARY_ASSIGNMENT;
                else
                    /*
                     * If the statement is binary expression and it does not
                     * contains "=", in this case it is hard to detect the type
                     * of the statement. We ignore this circumstance!
                     *
                     */
                    return ISymbolicExecution.IGNORE;

            else if (_stm instanceof IASTFunctionCallExpression)
                /*
                 * Ignore the statement corresponding to function call.
                 */
                return ISymbolicExecution.UNSPECIFIED_STATEMENT;

            else if (_stm instanceof IASTUnaryExpression) {
                IASTUnaryExpression unaryStm = (IASTUnaryExpression) _stm;

                switch (unaryStm.getOperator()) {
                    case IASTUnaryExpression.op_prefixIncr:
                    case IASTUnaryExpression.op_postFixIncr:
                    case IASTUnaryExpression.op_prefixDecr:
                    case IASTUnaryExpression.op_postFixDecr:
                    case IASTUnaryExpression.op_star:
                    case IASTUnaryExpression.op_amper:
                        /*
                         * Ex1: a++; Ex2: a--; Ex3: --a; Ex4:++a; Ex5: *a; Ex6: &a
                         */
                        return ISymbolicExecution.UNARY_ASSIGNMENT;

                    case IASTUnaryExpression.op_throw:
                        /*
                         * Ex: throw 1
                         */
                        return ISymbolicExecution.THROW;

                    default:
                        return ISymbolicExecution.UNSPECIFIED_STATEMENT;
                }
            } else
                /*
                 * Does not handle the remaining circumstances.
                 */
                return ISymbolicExecution.UNSPECIFIED_STATEMENT;

        } else if (stm instanceof IASTDeclarationStatement)
            return ISymbolicExecution.DECLARATION;

        else if (stm instanceof IASTReturnStatement)
            return ISymbolicExecution.RETURN;

        else if (stm instanceof ICPPASTBinaryExpression && ASTUtils.isBinaryAssignment((IASTBinaryExpression) stm))
            return ISymbolicExecution.BINARY_ASSIGNMENT;

        else if (containFunctionCall(stm))
            return ISymbolicExecution.UNSPECIFIED_STATEMENT;

        return ISymbolicExecution.UNSPECIFIED_STATEMENT;
    }

    private boolean containFunctionCall(IASTNode ast) {

        ASTVisitor visitor = new ASTVisitor() {

            @Override
            public int visit(IASTExpression expression) {
                if (expression instanceof IASTFunctionCallExpression) {
                    Utils.containFunction = true;
                    return ASTVisitor.PROCESS_ABORT;
                } else
                    return ASTVisitor.PROCESS_CONTINUE;
            }
        };
        visitor.shouldVisitStatements = true;
        visitor.shouldVisitExpressions = true;
        ast.accept(visitor);
        return Utils.containFunction;
    }

    /**
     * Parse the scope statement
     *
     * @param stm
     * @param scopeLevel the new scope level
     * @param table
     */
    private int parseScope(ICfgNode stm, int scopeLevel, IVariableNodeTable table) {
        if (stm.getContent().equals("{"))
            scopeLevel++;
        else {
            table.deleteScopeLevelAt(scopeLevel);
            scopeLevel--;
        }
        return scopeLevel;
    }

    /**
     * Parse the declaration
     *
     * @param ast
     * @param scopeLevel
     * @param table
     * @return true if the declaration of variable is supported
     * @throws Exception
     */
    private boolean parseDeclaration(IASTNode ast, int scopeLevel, VariableNodeTable table,
                                     INode function) throws Exception {
        if (ast instanceof IASTDeclarationStatement && function instanceof IFunctionNode) {
            IASTDeclarationStatement declarationStm = (IASTDeclarationStatement) ast;

            IASTDeclaration declaration = declarationStm.getDeclaration();
            if (declaration instanceof IASTSimpleDeclaration) {
                IASTSimpleDeclaration stm3 = (IASTSimpleDeclaration) declaration;

                DeclarationParser declarationParser = new DeclarationParser();
                declarationParser.setScopeLevel(scopeLevel);
                declarationParser.setFunction((IFunctionNode) function);
                declarationParser.parse(stm3, table, callTable);
            }
        }

        return true;
    }

    /**
     * Parse the condition
     *
     * @param stm
     * @param originAST
     * @param count
     * @param table
     * @return true if the condition is supported. Otherwise, it returns false
     * @throws Exception
     */
    private boolean parseCondition(ICfgNode stm, IASTNode originAST, int count, VariableNodeTable table, boolean containStubVar) throws Exception {
        // get real content of stm
        String content = stm.getContent();
        if (stm instanceof ReturnNode) {
            content = originAST.getRawSignature();
        }
        if(containStubVar) {
            content = originAST.getRawSignature();
        }
        content = ExpressionRewriterUtils.rewriteMacro(functionNode, content);

        // convert stm to ast
        IASTNode ast = Utils.convertToIAST(content);
        ast = Utils.shortenAstNode(ast);

        if (ASTUtils.isSingleCodition(ast)) {
            if (ast instanceof ICPPASTLiteralExpression || ast instanceof IASTIdExpression) {
                /*
                 * Ex: (a)
                 */
                String var = content;
                PhysicalCell r = table.findPhysicalCellByName(var);

                if (r != null) {

                    List<ISymbolicVariable> vars = table.findVariablesContainingCell(r);
                    if (vars.size() == 1) {
                        ISymbolicVariable firstVar = vars.get(0);

                        if (firstVar instanceof BasicSymbolicVariable)
                            this.constraints
                                    .add(new PathConstraint(((BasicSymbolicVariable) firstVar).getSymbolicValue() + "==1",
                                            stm, PathConstraint.CREATE_FROM_DECISION));
                    } else
                        throw new Exception("Dont support " + stm + " / " + content);
                }
            } else {
                ConditionParser conditionParser = new ConditionParser();
                conditionParser.parse(ast, table, callTable);
                //get owner ((CPPASTFieldReference)((CPPASTFieldReference)((CPPASTArraySubscriptExpression)((IASTBinaryExpression)Utils.convertToIAST(str)).getOperand1()).arrayExpression).fOwner).fOwner
                //compare name tableMapping.get(0).getName().equals(((CPPASTIdExpression)((CPPASTBinaryExpression)Utils.convertToIAST(str)).fOperand2).toString())
                this.constraints
                        .add(new PathConstraint(conditionParser.getNewConstraint(), stm, PathConstraint.CREATE_FROM_DECISION));
            }
        } else if (ASTUtils.isMultipleCodition(ast)) {
            logger.debug("is multiple condition");

            ConditionParser conditionParser = new ConditionParser();
            conditionParser.parse(ast, table, callTable);
            this.constraints
                    .add(new PathConstraint(conditionParser.getNewConstraint(), stm, PathConstraint.CREATE_FROM_DECISION));

        } else
            throw new Exception("Dont support " + stm + " / " + content);

        return true;

    }
    private void collectStubVar(IASTNode nodeAst){
        if(nodeAst instanceof IASTBinaryExpression){
            handleRecursiveBinaryExp((IASTBinaryExpression) nodeAst, nodeAst);
        }
        else if(nodeAst instanceof IASTDeclarationStatement){
            IASTDeclaration declaration = ((IASTDeclarationStatement)nodeAst).getDeclaration();
            if(declaration instanceof IASTSimpleDeclaration){
                IASTDeclarator declarator = ((IASTSimpleDeclaration)declaration).getDeclarators()[0];
                IASTInitializer initializer = declarator.getInitializer();
                if(initializer instanceof IASTEqualsInitializer){
                    IASTInitializerClause clause =  ((IASTEqualsInitializer)initializer).getInitializerClause();
                    if(clause instanceof IASTFunctionCallExpression){
                        handleStubVar((IASTExpression) clause, nodeAst);
                    }
                    else if(clause instanceof IASTUnaryExpression){
                        handleRecursiveUnaryExp((IASTUnaryExpression) clause,nodeAst);
                    }
                    else if(clause instanceof IASTBinaryExpression){
                        handleRecursiveBinaryExp((IASTBinaryExpression) clause,nodeAst);
                    }
                }

            }
        }
        else if(nodeAst instanceof IASTUnaryExpression){
            handleRecursiveUnaryExp((IASTUnaryExpression) nodeAst, nodeAst);
        }
        else if(nodeAst instanceof IASTExpressionStatement){
            IASTExpression op = ((IASTExpressionStatement)nodeAst).getExpression();
            if(op instanceof IASTBinaryExpression) {
                handleRecursiveBinaryExp((IASTBinaryExpression)op, nodeAst);
            }
        }
    }
    private void handleRecursiveBinaryExp(IASTBinaryExpression nodeAst, IASTNode originalAst){
        IASTExpression op1 = ((IASTBinaryExpression)nodeAst).getOperand1();
        IASTExpression op2 = ((IASTBinaryExpression)nodeAst).getOperand2();
        if(op1 instanceof IASTFunctionCallExpression){
            handleStubVar(op1, originalAst);
        }
        else if(op1 instanceof IASTBinaryExpression){
            handleRecursiveBinaryExp((IASTBinaryExpression)op1, originalAst);
        }
        else if(op1 instanceof IASTUnaryExpression){
            handleRecursiveUnaryExp((IASTUnaryExpression)op1, originalAst);
        }
        if(op2 instanceof  IASTFunctionCallExpression){
            handleStubVar(op2, originalAst);
        }
        else if(op2 instanceof IASTBinaryExpression){
            handleRecursiveBinaryExp((IASTBinaryExpression)op2, originalAst);
        }
        else if(op2 instanceof IASTUnaryExpression){
            handleRecursiveUnaryExp((IASTUnaryExpression)op2, originalAst);
        }
    }
    private void handleRecursiveUnaryExp(IASTUnaryExpression nodeAst, IASTNode originalAst){
        IASTExpression op = ((IASTUnaryExpression)nodeAst).getOperand();
        if(op instanceof IASTFunctionCallExpression){
            handleStubVar(op,originalAst);
        }
        else if(op instanceof IASTUnaryExpression){
            int operator = ((IASTUnaryExpression)op).getOperator();
            if (operator == 7 || operator == 11){
                IASTExpression operand = ((IASTUnaryExpression)op).getOperand();
                if(operand instanceof IASTUnaryExpression){
                    handleRecursiveUnaryExp((IASTUnaryExpression)operand, originalAst);
                }
                else if(operand instanceof IASTBinaryExpression){
                    handleRecursiveBinaryExp((IASTBinaryExpression)operand, originalAst);
                }
            }
        }
        else if(op instanceof IASTBinaryExpression){
            handleRecursiveBinaryExp((IASTBinaryExpression) op, originalAst);
        }
    }
    private void handleStubVar(IASTNode op, IASTNode originalAst){
        String originalName = op.getRawSignature();
        String replaceString ="";
//        if(op instanceof IASTFieldReference || op instanceof IASTArraySubscriptExpression ){
//            String[] fieldSplit = originalName.split("\\.");
//            Queue<String> queue = new LinkedList<>(Arrays.asList(fieldSplit));
//            String owner = queue.poll();
//            String attr = "";
//            if(!(parameterNames.contains(owner))){
//                for(StructMap stmap : listStructMap){
//                    if(stmap.structName.equals(owner)){
//                        StructNode structNode = stmap.structNode;
//                        IASTNode structNodeAst = structNode.getAST();
//                        String structNodeDeclSpecifier = ((IASTSimpleDeclaration) structNodeAst).getDeclSpecifier().toString();
//                        String structName = structNode.getName();
//                        String stubName = "akaut_stub_" + structName + "_call";
//
//
//                        while(!queue.isEmpty()){
//                            attr += "___attr___"+queue.poll();
//                        }
//                        for(String name : parameterNames){
//                            if(name.startsWith(stubName) && name.endsWith(attr)){
//                                replaceString = name;
//                                parameterNames.remove(name);
//                                break;
//                            }
//                        }
//                        break;
//                    }
//                }
//            }
//            else replaceString = originalName;
//        }
//        else{
            String reducedStubName = "";
            if(op instanceof IASTFunctionCallExpression){
                reducedStubName = originalName.substring(0,originalName.lastIndexOf("("));
            }
//            else{
//                for(Node stubNode : listStubNode){
//                    if(stubNode instanceof StructNode){
//                        String opDeclSpecififer = ((IASTSimpleDeclaration) op).getDeclSpecifier().toString();
//                        IASTNode structNodeAst = ((StructNode)stubNode).getAST();
//                        String structNodeDeclSpecifier = ((IASTSimpleDeclaration) structNodeAst).getDeclSpecifier().toString();
//                        if (opDeclSpecififer.equals(structNodeDeclSpecifier)) {
//                            String structName = stubNode.getName();
//                            reducedStubName = structName;
//
//                            String declarator = ((IASTSimpleDeclaration) op).getDeclarators()[0].getName().toString();
//                            StructMap stmap = new StructMap(declarator, (StructNode) stubNode);
//                            listStructMap.add(stmap);
//                            break;
//                        }
//                    }
//                }
//            }
            String stubName = "akaut_stub_"+reducedStubName+"_call";

            for(String name : parameterNames){
                if(name.startsWith(stubName)){
                    replaceString = name;
                    parameterNames.remove(name);
                    break;
                }
            }
//        }
        if(newAstString == ""){
            String newCfgAstString = originalAst.getRawSignature().replace(originalName,replaceString);
            newAstString = newCfgAstString;
        }
        else{
            newAstString = newAstString.replace(originalName,replaceString);
        }
    }

    /**
     * Get the normalized path constraints to be solved by smt-solver
     *
     * @return
     */
    @Override
    public PathConstraints getNormalizedPathConstraints() {
        PathConstraints newPcs = new PathConstraints();
        for (PathConstraint pc : this.constraints) {
            String constraintStr = pc.getConstraint();
            constraintStr = VariableNodeTable.normalizeNameOfVariable(constraintStr);
            //
//            ConstraintNormalizer norm = new ConstraintNormalizer();
//            norm.setOriginalSourcecode(constraintStr);
//            norm.normalize();
//            constraintStr = norm.getNormalizedSourcecode();
            // "NULL" --> "0" because SMT-Solver does not understand NULL value
            constraintStr = constraintStr.replaceAll("\\s*!=\\s*\\bNULL\\b", ">0");

            newPcs.add(new PathConstraint(constraintStr, pc.getCfgNode(), pc.getType()));
        }
        return newPcs;
    }

    @Override
    public IPathConstraints getConstraints() {
        return this.constraints;
    }

    @Override
    public void setConstraints(PathConstraints constraints) {
        this.constraints = constraints;
    }

    @Override
    public Parameters getParameters() {
        return this.parameters;
    }

    @Override
    public void setParameters(Parameters parameters) {
        this.parameters = parameters;
    }

    @Override
    public String getReturnValue() {
        return this.returnValue;
    }

    @Override
    public void setReturnValue(String returnValue) {
        this.returnValue = returnValue;
    }

    @Override
    public IVariableNodeTable getTableMapping() {
        return this.tableMapping;
    }

    @Override
    public void setTableMapping(VariableNodeTable tableMapping) {
        this.tableMapping = tableMapping;
    }

    @Override
    public ITestpathInCFG getTestpath() {
        return this.testpath;
    }

    @Override
    public void setTestpath(ITestpathInCFG testpath) {
        this.testpath = testpath;
    }

    public Set<NewVariableInSe> getNewVariables() {
        return newVariables;
    }

    public void setNewVariables(Set<NewVariableInSe> newVariables) {
        this.newVariables = newVariables;
    }
}
