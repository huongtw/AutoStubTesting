package auto_testcase_generation.testdatagen;

import auto_testcase_generation.cfg.object.ConditionCfgNode;
import auto_testcase_generation.cfg.object.ICfgNode;
import com.dse.config.AkaConfig;
import com.dse.config.WorkspaceConfig;
import com.dse.guifx_v3.controllers.TestCasesNavigatorController;
import com.dse.guifx_v3.helps.UIController;
import com.dse.guifx_v3.helps.UILogger;
import com.dse.parser.object.INode;
import com.dse.testcase_execution.TestcaseExecution;
import com.dse.testcase_manager.*;
import com.dse.testdata.gen.module.TreeExpander;
import com.dse.testdata.object.RootDataNode;
import com.dse.thread.AkaThread;
import com.dse.thread.AkaThreadManager;
import com.dse.thread.task.AutoGeneratedTestCaseExecTask;
import com.dse.thread.task.GenerateTestdataTask;
import com.dse.parser.object.*;
import com.dse.search.Search2;
import com.dse.testdata.InputCellHandler;
import com.dse.testdata.object.*;
import com.dse.logger.AkaLogger;
import com.dse.user_code.objects.UsedParameterUserCode;
import com.dse.util.IRegex;
import com.dse.util.SourceConstant;
import com.dse.util.Utils;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.File;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.stream.Collectors;

/**
 * Automated test data generation
 */
public abstract class AbstractAutomatedTestdataGeneration implements IAutomatedTestdataGeneration {
    final static AkaLogger logger = AkaLogger.get(AbstractAutomatedTestdataGeneration.class);

    protected List<String> analyzedTestpathMd5 = new ArrayList<>(); // to avoid analyze the existing test paths

    protected List<String> generatedTestcases = new ArrayList<>(); // to avoid analyze the existing test paths

    protected GenerateTestdataTask functionExecThread;

    // When we test a function of a class, we need to construct a specified constructor
    protected IFunctionNode selectedConstructor;

    // each prototype is a test case (just define the template type of template function)
    protected List<TestPrototype> allPrototypes = new ArrayList<>();

//    protected List<TestCase> outputs = new ArrayList<>();

    protected List<Callable<Object>> tasks = new ArrayList<>();

    /**
     * List of generated test cases
     */
    protected List<TestCase> testCases = new ArrayList<>();

    protected List<AutoGeneratedTestCaseExecTask> execTasks = new ArrayList<>();

    protected String coverageType;

    protected boolean maximizeCov = false;

    // store the template type to real type in template function, e.g, "T"->"int"
    // key: template type
    // value: real type
    protected Map<String, String> realTypeMapping;

    /**
     * Should execute test cases parallel ot nor
     */
    protected boolean shouldRunParallel = false;

    /**
     * Show report after automated test data generation
     */
    protected boolean showReport = false;

    // Number of using solver
    public static int numOfSolverCalls = 0;
    // Number of symbolic execution
    public static int numOfSymbolicExecutions = 0;
    // Number of symbolic statements. In each symbolic execution, some of
    // statements will be symbolic.
    public static int numOfSymbolicStatements = 0;
    // Number of execution
    public static int numOfExecutions = 0;
    // Number of solver calls but its solution does not increase coverage
    public static int numOfNotChangeToCoverage = 0;
    // Number of solver calls but can not solve (cause errors)
    public static int numOfSolverCallsbutCannotSolve = 0;
    // The total time of running make command (ms)
    public static long makeCommandRunningTime = 0;
    // The number of running make command
    public static int makeCommandRunningNumber = 0;
    // The total time of execution time (ms)
    public static long executionTime = 0;
    // The total time of waiting solver to get solution (ms)
    public static long solverRunningTime = 0;
    // The total time of generating test data (ms)
    public static long totalRunningTime;
    // The total time of normalizing function (ms)
    public static long normalizationTime;
    // The total time of symbolic execution (ms)
    public static long symbolicExecutionTime;
    // The total time of macro normalization (ms)
    public static long macroNormalizationTime;
    // Bugs detected while executing the program
    public static Set<Bug> bugs = new HashSet<>();
    // Testdata
    public static List<TestdataInReport> testdata = new ArrayList<>();
    // Code coverage
    public static float branchCoverage = 0.0f;
    public static float statementCoverage = 0.0f;

    public static boolean isTerminateDuetoTooLong = false;

    // DOES NOT RESET THESE FOLLOWING FIELDS (FOR SUMMARY PURPOSE)
    public static int numOfBranches = 0;// OVERALL SCOPE
    public static int numOfVisitedBranches = 0;// OVERALL SCOPE
    public static int totalSolverCalls = 0;// OVERALL SCOPE
    public static int totalNumOfExecution = 0;// OVERALL SCOPE
    public static int totalSymbolicStatements = 0;// OVERALL SCOPE
    // item = {iteration, visited branches}
    public static List<Integer[]> visitedBranchesInfor = new ArrayList<>();// OVERALL
    // SCOPE
    public static int tmp_iterations = 0;// OVERALL SCOPE
    public static int currentNumOfVisitedBranches = 0;// OVERALL SCOPE

    public static int removedConstraints = 0; // OVERALL SCOPE
    public static int removedTestdata = 0;// OVERALL SCOPE

    protected ICommonFunctionNode fn;
    protected InputCellHandler inputCellHandler;

    public AbstractAutomatedTestdataGeneration(ICommonFunctionNode fn) {
        this.fn = fn;

        numOfSolverCalls = 0;
        numOfSymbolicExecutions = 0;
        numOfSymbolicStatements = 0;
        numOfExecutions = 0;
        numOfSolverCallsbutCannotSolve = 0;
        makeCommandRunningTime = 0;
        makeCommandRunningNumber = 0;
        solverRunningTime = 0;
        totalRunningTime = 0;
        executionTime = 0;
        normalizationTime = 0;
        symbolicExecutionTime = 0;
        macroNormalizationTime = 0;
        bugs = new HashSet<>();
        testdata = new ArrayList<>();
        branchCoverage = 0f;
        statementCoverage = 0f;
        isTerminateDuetoTooLong = false;

        inputCellHandler = new InputCellHandler();
        inputCellHandler.setInAutoGenMode(true);
    }

    protected void onGenerateSuccess(boolean showReport) {
        // view coverage of generated set of test cases
        if (showReport) {
            List<TestCase> testCases = TestCaseManager.getTestCasesByFunction(fn);
//            int nTestcases = testCases.size();
//            UILogger.getUiLogger().info("[DONE] Generate test cases for function " + fn.getName() + ". Total of test cases in this function:" + nTestcases);

            // view coverage of the function with all test cases (old test cases and new test cases)
            UIController.viewCoverageOfMultipleTestcasesFromAnotherThread(fn.getName(), testCases);
        }

        TestCasesNavigatorController.getInstance().refreshNavigatorTreeFromAnotherThread();
    }

    public String getDisplayName(String name) {
        int check = 0;
        for (int i = 0; i < name.length(); i++) {
            if (name.charAt(i) == '(') {
                check = i;
            }
        }
        name = name.substring(0, check);
        return name;
    }

    private String getValue(IDataNode node, List<RandomValue> values) {
        String virtualNameOfNode = RandomValue.convertNameUsedInExpansionToCode(node.getVituralName());

        List<String> candidates = values.stream()
                .filter(v -> v.getNameUsedToUpdateValue().equals(virtualNameOfNode))
                .map(RandomValue::getValue)
                .distinct()
                .collect(Collectors.toList());

        String value = null;
        if (candidates.size() == 1)
            value = candidates.get(0);
        else if (!candidates.isEmpty()) {
            if (node instanceof PointerDataNode) {
                value = candidates.stream().filter(c -> !c.matches("[0-9]+")).findFirst().orElse(candidates.get(candidates.size() - 1));
            } else
                value = candidates.get(0);
        }

        if (node instanceof ClassDataNode) {
            if (value == null || value.equals("0") || value.equals("0.0")) {
                List<IVariableNode> argsOfNode = this.fn.getArguments();
                ClassNode classNode = null;
                for (IVariableNode arg : argsOfNode) {
                    if (arg.getName().equals(node.getName())) {
                        classNode = (ClassNode)arg.resolveCoreType();
                        break;
                    }
                }
                if (classNode != null) {
                    if (classNode.getConstructors().size() > 0) {
                        value = ((ClassDataNode) node).getRawType() + "(";
                        List<IVariableNode> argsOfConstructor = classNode.getConstructors().get(0).getArguments();
                        for (IVariableNode arg : argsOfConstructor) {
                            value += arg.getRawType() + ",";
                            //values.add(new RandomValue(node.getName() + "_" + arg.getName(), "0"));
                        }
                        if (value.endsWith(",")) {
                            value = value.substring(0, value.length() - 1);
                        }
                        value += ")";
                    }
                } else {
                    logger.debug("Cannot find class node for " + node.getName());
                }
            }
        }

        if (node instanceof SubprogramNode && !(node instanceof IterationSubprogramNode)) {
            String subProgramNodeName = node.getName();
            subProgramNodeName = getDisplayName(subProgramNodeName);
            for (RandomValue randomValue : values) {
                if (randomValue.getNameUsedInExpansion().equals("akaut_stub_" + subProgramNodeName + "_Number_of_Calls")) {
                    if (value == null || value.equals("0") || value.equals("0.0")) {
                        value = randomValue.getValue();
                    }
                }
            }
        }

        if (node instanceof NumberOfCallNode) {
            value = ((NumberOfCallNode) node).getValue();
        }

        if (node.getParent() instanceof IterationSubprogramNode && node.getName().equals("RETURN") && node instanceof PointerDataNode) {
            IterationSubprogramNode parent  = (IterationSubprogramNode) node.getParent();
            int count_variable = 0;
            for (RandomValue randomValue : values) {
                if (randomValue.getNameUsedInExpansion().contains(parent.getName() + "[")) {
                    count_variable++;
                }
            }
            value = String.valueOf(count_variable);
        } else if (node.getParent() != null && node.getParent().getName().equals("RETURN") && node.getParent() instanceof StructDataNode && node.getParent().getParent() instanceof IterationSubprogramNode) {
            IterationSubprogramNode parent  = (IterationSubprogramNode) node.getParent().getParent();
            for (RandomValue randomValue : values) {
                if (randomValue.getNameUsedInExpansion().equals("akaut_stub_" + parent.getName() + "." + node.getName())) {
                    if (value == null || value.equals("0") || value.equals("0.0")) {
                        value = randomValue.getValue();
                    }
                }
            }
        } else if (node.getParent() != null && node.getParent().getName().equals("RETURN") && node.getParent() instanceof UnionDataNode && node.getParent().getParent() instanceof IterationSubprogramNode) {
            IterationSubprogramNode parent  = (IterationSubprogramNode) node.getParent().getParent();
            for (RandomValue randomValue : values) {
                if (randomValue.getNameUsedInExpansion().equals("((akaut_stub_" + parent.getName() + "+0))." + node.getName())) {
                    if (value == null || value.equals("0") || value.equals("0.0")) {
                        value = randomValue.getValue();
                    }
                }
            }
        } else if (node.getParent() instanceof IterationSubprogramNode && node.getName().equals("RETURN")) {
            IterationSubprogramNode parent  = (IterationSubprogramNode) node.getParent();
            for (RandomValue randomValue : values) {
                if (randomValue.getNameUsedInExpansion().equals("akaut_stub_" + parent.getName())) {
                    if (value == null || value.equals("0") || value.equals("0.0")) {
                        value = randomValue.getValue();
                    }
                }
            }
        }

        return value;
    }

    public void addNumberOfCallNode(IDataNode node, String value) {
        NumberOfCallNode numberOfCallNode = new NumberOfCallNode("Number of calls");
        numberOfCallNode.setValue(value);
        node.addChild(numberOfCallNode);
        numberOfCallNode.setParent(node);

    }

    public void recursiveExpandUutBranch(IDataNode node, List<RandomValue> values, TestCase testCase) throws Exception {
        logger.debug("recursiveExpandUutBranch with \"" + node.getName() + "\"");
        // STEP 1: set & get virtual name of current node
        node.setVirtualName();

        // STEP 2: get raw value from static solutions
        String value = getValue(node, values);

        // STEP 3: commit edit with value

        if (value != null) {
            if ((node.getParent().getName().equals("SBF") || node.getParent() instanceof StubUnitNode) && node instanceof SubprogramNode && !(node instanceof IterationSubprogramNode)) {
                addNumberOfCallNode(node, value);
            }

            if (node instanceof VoidPointerDataNode) {
                // nothing to do
            } else if (node instanceof OtherUnresolvedDataNode) {
                // nothing to do
            } else if (node instanceof ClassDataNode && !(node instanceof SubClassDataNode)) {
                // Ex: key = "sv", value="Student(int,int)"
                // get name of the constructor
                if (value.contains("("))
                    value = value.substring(0, value.indexOf('('));
                if (value.contains("::"))
                    value = value.substring(value.indexOf("::") + 2).trim();
            } else if (node instanceof NormalCharacterDataNode && !value.isEmpty()) {
                value = NormalCharacterDataNode.toASCII(value) + "";
            }

            if (node instanceof ValueDataNode)
                try {
                    ValueDataNode valueNode = (ValueDataNode) node;
                    if (valueNode instanceof PointerDataNode && !value.matches("-{0,1}[0-9]+")) {
                        PointerDataNode pointerNode = (PointerDataNode) valueNode;
                        UsedParameterUserCode userCode = new UsedParameterUserCode();
                        userCode.setType(UsedParameterUserCode.TYPE_CODE);
                        String content = pointerNode.getVituralName() + "=" + value + ";";
                        userCode.setContent(content);
                        pointerNode.setUserCode(userCode);
                        pointerNode.setUseUserCode(true);
                        testCase.putOrUpdateDataNodeIncludes(pointerNode);
                    } else if (!(valueNode instanceof StructDataNode
                            || (valueNode instanceof ArrayDataNode && ((ArrayDataNode) valueNode).isFixedSize()))) {
                        if (!value.isEmpty()) {
                            logger.debug("Commit edit for node \"" + valueNode.getName() + "\"; value = \"" + value + "\", class = " + valueNode.getClass().getSimpleName());
                            inputCellHandler.setRealTypeMapping(realTypeMapping);
                            inputCellHandler.setTestCase(testCase);
                            inputCellHandler.commitEdit(valueNode, value);
                        }
                    }

                    if (valueNode instanceof ArrayDataNode || valueNode instanceof PointerDataNode) {
                        int dim = 1;
                        if (valueNode instanceof MultipleDimensionDataNode)
                            dim = ((MultipleDimensionDataNode) valueNode).getDimensions();
                        StringBuilder regexBuilder = new StringBuilder();
                        regexBuilder.append("\\Q").append(valueNode.getName()).append("\\E");
                        for (int i = 0; i < dim; i++)
                            regexBuilder.append(IRegex.ARRAY_INDEX);
                        final String childNameRegex = regexBuilder.toString();
                        List<String> children = values.stream()
                                .map(RandomValue::getNameUsedInExpansion)
                                .filter(name -> name.matches(childNameRegex))
                                .collect(Collectors.toList());
                        for (String child : children) {
                            boolean exist = valueNode.getChildren().stream()
                                    .anyMatch(c -> c.getName().equals(child));
                            if (!exist) {
                                DataNode childNode = new TreeExpander().generateArrayItem(child, valueNode);
                                valueNode.getChildren().add(childNode);
                            }
                        }
                    }

                    if (valueNode.getParent() instanceof IterationSubprogramNode && valueNode.getName().equals("RETURN") && valueNode instanceof PointerDataNode) {
                        IterationSubprogramNode parent  = (IterationSubprogramNode) valueNode.getParent();
                        int pointer_size = Integer.parseInt(value) - 1;
                        for (RandomValue randomValue : values) {
                            if (randomValue.getNameUsedInExpansion().contains(parent.getName() + "[")) {
                                String name = randomValue.getNameUsedInExpansion();
                                int check = name.indexOf('[');
                                name = name.substring(check, name.length());
                                String variable_name = "RETURN" + name;
                                valueNode.getChildren().get(pointer_size).setName(variable_name);
                                inputCellHandler.setRealTypeMapping(realTypeMapping);
                                inputCellHandler.setTestCase(testCase);
                                inputCellHandler.commitEdit(((NormalNumberDataNode)valueNode.getChildren().get(pointer_size)), randomValue.getValue());
                                pointer_size--;
                            }
                        }
                    }

                    if (valueNode.getParent() instanceof IterationSubprogramNode && valueNode.getName().equals("RETURN") && valueNode instanceof UnionDataNode) {
                        String attribute = "";
                        for (int i = 0; i < valueNode.getCorrespondingType().getChildren().size(); i++) {
                            for (RandomValue randomValue : values) {
                                if (randomValue.getNameUsedInExpansion().contains(valueNode.getCorrespondingType().getChildren().get(i).getName())) {
                                    attribute = valueNode.getCorrespondingType().getChildren().get(i).getName();
                                }
                            }
                        }
                        inputCellHandler.setRealTypeMapping(realTypeMapping);
                        inputCellHandler.setTestCase(testCase);
                        inputCellHandler.commitEdit(valueNode, attribute);
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                }
        }

        // STEP 4: repeat with its children
        for (IDataNode child : node.getChildren())
            recursiveExpandUutBranch(child, values, testCase);
    }

    /**
     * The data tree is expanded automatically while generating randomly
     *
     * @param root the root of data tree
     * @param sut  a function
     * @return
     * @throws Exception
     */
    protected List<RandomValue> generateRandomValueForArguments(RootDataNode root, ICommonFunctionNode sut,
                                                                List<String> additionalHeaders,
                                                                TestPrototype selectedPrototype,
                                                                TestCase testCase) throws Exception {
        List<RandomValue> values;
        RandomInputGeneration random = new RandomInputGeneration();
        random.setFunctionNode(sut);
        random.setRoot(root);
        random.setSelectedPrototype(selectedPrototype);
        realTypeMapping = new VoidPtrTypeResolver(fn).getTypeMap();
        random.setRealTypeMapping(realTypeMapping);
        values = random.constructRandomInput(sut.getArguments(), sut.getFunctionConfig(), "");

        // get mapping between template type and real type
        SubprogramNode subprogramNode = Search2.findSubprogramUnderTest(root);
        if (subprogramNode instanceof TemplateSubprogramDataNode) {
            this.realTypeMapping = ((TemplateSubprogramDataNode) subprogramNode).getRealTypeMapping();
        } else if (subprogramNode instanceof MacroSubprogramDataNode) {
            this.realTypeMapping = ((MacroSubprogramDataNode) subprogramNode).getRealTypeMapping();
        }

        IDataNode sutRoot = Search2.findSubprogramUnderTest(root);
        recursiveExpandUutBranch(sutRoot, values, testCase);
        additionalHeaders.add(testCase.getAdditionalHeaders());
        return values;
    }

    /**
     * Create the instance of a class to execute a function in that class
     * <p>
     * The data tree is expanded automatically while generating randomly
     *
     * @param root the root of data tree
     * @param sut  a function
     * @return a random instance
     * @throws Exception
     */
    protected List<RandomValue> generateRandomValuesForInstance(RootDataNode root, ICommonFunctionNode sut, TestCase testCase) {
        List<RandomValue> values = null;
        try {
            RootDataNode globalRoot = Search2.findGlobalRoot(root);

            // find the class where the function is put in
            // if the function is not in a class, we get its source code file
            INode classNode = null;
            if (sut instanceof IFunctionNode)
                classNode = ((IFunctionNode) sut).getRealParent();
            else
                classNode = sut.getParent();

            if (classNode == null || !(classNode instanceof ClassNode))
                // the function is not in a class
                return null;

            ClassDataNode candidateClass = null;
            for (IDataNode child : globalRoot.getChildren())
                if (child instanceof ClassDataNode)
                    // if the global node is corresponding to an instance
                    if (child.getName().startsWith(SourceConstant.INSTANCE_VARIABLE))
                        if (((ClassDataNode) child).getCorrespondingType().getAbsolutePath().equals(classNode.getAbsolutePath())) {
                            candidateClass = (ClassDataNode) child;
                        }

            // select a random instance
            if (candidateClass == null)
                return null;

            // initialize the instance
            TmpVariableNode variableNode = new TmpVariableNode();
            variableNode.setRawType(candidateClass.getRawType());
            variableNode.setCoreType(candidateClass.getRawType());
            variableNode.setReducedRawType(candidateClass.getRawType());
            variableNode.setName(candidateClass.getName());
            variableNode.setCorrespondingNode(candidateClass.getCorrespondingType());
            variableNode.setParent(fn);

            List<IVariableNode> vars = new ArrayList<>();
            vars.add(variableNode);

            // update the data tree and generate random values for arguments in the created instance
            RandomInputGeneration randomInputGeneration = new RandomInputGeneration();
            randomInputGeneration.setFunctionNode(sut);
            if (fn instanceof ConstructorNode)
                randomInputGeneration.setSelectedConstructor((ConstructorNode) fn);
            values = randomInputGeneration.constructRandomInput(vars, sut.getFunctionConfig(), "");
            recursiveExpandUutBranch(candidateClass, values, testCase);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return values;
    }

    protected List<RandomValue> generateRandomValuesForStub(RootDataNode root, ICommonFunctionNode sut, TestCase testCase) {
        List<RandomValue> values = null;
        try {
            List<SubprogramNode> stubSubprogramNodes = Search2.searchStubSubprograms(root);

            logger.debug("Num of stub subprograms = " + stubSubprogramNodes.size());

            for (SubprogramNode subprogram : stubSubprogramNodes) {
                ValueDataNode returnNode = subprogram.getChildren().stream()
                        .filter(s -> s.getName().equals("RETURN") && s instanceof ValueDataNode)
                        .map(n -> (ValueDataNode) n)
                        .findFirst()
                        .orElse(null);

                if (returnNode != null) {
                    List<IVariableNode> vars = new ArrayList<>();
                    vars.add(returnNode.getCorrespondingVar());

                    // update the data tree and generate random values for arguments in the created instance
                    RandomInputGeneration randomInputGeneration = new RandomInputGeneration();
                    randomInputGeneration.setFunctionNode(sut);

                    // Ex: "Algorithm::Utils::a", name var = "Utils::a" --> prefix = "Algorithm::"
                    String prefixName = returnNode.getVituralName();
                    prefixName = prefixName.replaceAll(returnNode.getName() + "\\s*$", "");

                    values = randomInputGeneration.constructRandomInput(vars, sut.getFunctionConfig(), prefixName);
                    recursiveExpandUutBranch(returnNode, values, testCase);
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        return values;
    }

    protected List<RandomValue> generateRandomValuesForGlobal(RootDataNode root, ICommonFunctionNode sut, TestCase testCase) {
        List<RandomValue> values = new ArrayList<>();
        try {
            GlobalRootDataNode globalRoot = Search2.findGlobalRoot(root);

            List<ValueDataNode> globalDataNodes = new ArrayList<>();
            for (IDataNode child : globalRoot.getChildren()) {
                // not the instance
                if (!(child.getName().startsWith(SourceConstant.INSTANCE_VARIABLE))) {
                    if (child instanceof ValueDataNode) {
                        IVariableNode v = ((ValueDataNode) child).getCorrespondingVar();
                        if (globalRoot.isRelatedVariable(v)) {
                            globalDataNodes.add((ValueDataNode) child);
                        }
                    }
                }
            }
            logger.debug("Num of global data nodes = " + globalDataNodes);

            for (ValueDataNode globalDataNode : globalDataNodes) {
                List<IVariableNode> vars = new ArrayList<>();
                vars.add(globalDataNode.getCorrespondingVar());

                // update the data tree and generate random values for arguments in the created instance
                RandomInputGeneration randomInputGeneration = new RandomInputGeneration();
                randomInputGeneration.setFunctionNode(sut);

                // Ex: "Algorithm::Utils::a", name var = "Utils::a" --> prefix = "Algorithm::"
                String prefixName = globalDataNode.getVituralName();
                prefixName = prefixName.replaceAll(globalDataNode.getName() + "\\s*$", "");

                values.addAll(randomInputGeneration
                        .constructRandomInput(vars, sut.getFunctionConfig(), prefixName));
                recursiveExpandUutBranch(globalDataNode, values, testCase);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        return values;
    }

    public static List<TestPrototype> getAllPrototypesOfTemplateFunction(ICommonFunctionNode fn) {
        List<TestPrototype> allPrototypes = new ArrayList<>();
        GsonBuilder gsonBuilder = new GsonBuilder();
        Gson customGson = gsonBuilder.create();
        String prototypeFile = Utils.readFileContent(fn.getTemplateFilePath());
        PrototypeOfFunction prototypeOfFunction = customGson.fromJson(prototypeFile, PrototypeOfFunction.class);
        List<String> prototypes = prototypeOfFunction.getPrototypes();

        for (String prototype : prototypes) {
            TestPrototype selectedPrototype = TestCaseManager.getPrototypeByName(
                    new File(prototype).getName().replace(".json", ""),
                    new WorkspaceConfig().fromJson().getTestcaseDirectory(), true);
            allPrototypes.add(selectedPrototype);
        }
        return allPrototypes;
    }

    /**
     * Create a test case
     *
     * @param selectedPrototype
     * @param iteration
     * @return
     */
    protected TestCase createTestcase(TestPrototype selectedPrototype, int iteration, ICommonFunctionNode functionNode) {
        TestCase testCase = null;
        // create a new test case at each iteration
        String nameofTestcase = TestCaseManager.generateContinuousNameOfTestcase(functionNode.getSimpleName() + ITestCase.POSTFIX_TESTCASE_BY_RANDOM);

        if (selectedPrototype != null) {
            // create new test case based on the given prototype
//            testCase = TestCaseManager.createTestCase(functionNode, nameofTestcase);

            String prototypeContent = Utils.readFileContent(new File(selectedPrototype.getPath()));
//            String newTestcaseName = nameofTestcase;
            String newTestcaseJson = prototypeContent.replace(selectedPrototype.getName(), nameofTestcase);

            String newTestcaseFile = new File(selectedPrototype.getPath()).getParent() + File.separator + nameofTestcase + ".json";
            Utils.writeContentToFile(newTestcaseJson, newTestcaseFile);

            testCase = TestCaseManager.getBasicTestCaseByName(nameofTestcase, new WorkspaceConfig().fromJson().getTestcaseDirectory()
                    , true);

            if (testCase != null) {
                String fullPathOfTestcase = new File(new WorkspaceConfig().fromJson().getTestcaseDirectory()).getAbsolutePath() + File.separator + testCase.getName() + ".json";
                logger.debug("initParameterExpectedOuputs");
                //testCase.initParameterExpectedOutputs();
                testCase.initParameterExpectedOutputsWithPrototype(fullPathOfTestcase);

                logger.debug("initGlobalInputExpOutputMap");
                testCase.initGlobalInputExpOutputMap();
            }

            logger.debug("Load prototype " + selectedPrototype.getPath());
            logger.debug("Create new test case from prototype: " + testCase.getPath());
        } else {
            testCase = TestCaseManager.createTestCase(nameofTestcase, functionNode);
        }

        if (testCase != null) {
            TestCaseManager.getNameToBasicTestCaseMap().put(testCase.getName(), testCase);
            Set<String> testcaseNames = TestCaseManager.getFunctionToTestCasesMap().get(functionNode);
            if (testcaseNames != null) {
                testcaseNames.add(testCase.getName());
            }
            testCase.setCreationDateTime(LocalDateTime.now());

            String testpathFileName = nameofTestcase + "__iter__" + iteration; // to avoid the misunderstanding between system separator and its name
            String testpathFile = new WorkspaceConfig().fromJson().getTestpathDirectory() + File.separator + testpathFileName + ".tp";
            testCase.setTestPathFile(testpathFile);
        }
        return testCase;
    }

    protected void execute(List<TestCase> testCases, boolean showReport, List<AutoGeneratedTestCaseExecTask> execTasks,
                           boolean shouldRunParallel, GenerateTestdataTask functionExecThread) {
        for (TestCase testCase : testCases) {
            try {
                TestcaseExecution executor = new TestcaseExecution();
                executor.setFunction(fn);
                executor.setMode(TestcaseExecution.IN_AUTOMATED_TESTDATA_GENERATION_MODE);

                if (shouldRunParallel) {
                    // start
                    AutoGeneratedTestCaseExecTask task = new AutoGeneratedTestCaseExecTask(executor, testCase, execTasks);
                    task.setShowReport(showReport);

                    AkaThread thread = new AkaThread(task);
                    UILogger.getUiLogger().info("Executing test case: " + testCase);
                    AkaThreadManager.autoTestdataGenForFunctionThreadPool.execute(thread);
                    AkaThreadManager.akaThreadList.add(thread);
                    functionExecThread.getTestCaseExecTask().add(task);
                    execTasks.add(task);

                } else {
                    AutoGeneratedTestCaseExecTask task = new AutoGeneratedTestCaseExecTask(executor, testCase, execTasks);
                    task.setShowReport(showReport);
                    UILogger.getUiLogger().info("Executing test case: " + testCase);
                    task.run();
                }
            } catch (Exception e) {
                e.printStackTrace();
                testCases.remove(testCase);
                testCase.setStatus(TestCase.STATUS_FAILED);
                logger.debug("There is a problem with the current test case. Move to the next iteration.");
            }
        }
    }

    public GenerateTestdataTask getFunctionExecThread() {
        if (functionExecThread == null) {
            this.functionExecThread = new GenerateTestdataTask(showReport);
            this.functionExecThread.setFunction(this.fn);
        }
        return functionExecThread;
    }

    public void setFunctionExecThread(GenerateTestdataTask functionExecThread) {
        this.functionExecThread = functionExecThread;
    }

    public List<TestPrototype> getAllPrototypes() {
        return allPrototypes;
    }

    public void setAllPrototypes(List<TestPrototype> allPrototypes) {
        this.allPrototypes = allPrototypes;
    }

    public IFunctionNode getSelectedConstructor() {
        return selectedConstructor;
    }

    public void setSelectedConstructor(IFunctionNode selectedConstructor) {
        this.selectedConstructor = selectedConstructor;
    }

    protected static List<ICfgNode> normalizePath(List<ICfgNode> path) {
        List<ICfgNode> normalizedPath = new ArrayList<>();

        for (int i = 0; i < path.size(); i++) {
            ICfgNode n = path.get(i);
            if (n instanceof ConditionCfgNode) {
                if (i + 1 < path.size()) {
                    ICfgNode next = path.get(i + 1);
                    if ((n.getTrueNode().getId() == next.getId()
                            || n.getTrueNode().getTrueNode().getId() == next.getId())
                            && n.getFalseNode().getId() != next.getId()
                    ) {
                        normalizedPath.add(n);
                    } else {
                        ConditionCfgNode clone = new ConditionCfgNode(((ConditionCfgNode) n).getAst()) {
                            @Override
                            public boolean isVisitedTrueBranch() {
                                return super.isVisitedTrueBranch();
                            }
                        };
                        clone.setContent("!(" + n.getContent() + ")");
                        clone.setAst(Utils.convertToIAST(clone.getContent()));
                        // cfds addition
                        clone.setTrue(n.getFalseNode());
                        clone.setFalse(n.getTrueNode());
                        clone.setDefaultNode(n);
                        normalizedPath.add(clone);
                    }
                }
            } else {
                normalizedPath.add(n);
            }
        }

        return normalizedPath;
    }

    public void setShowReport(boolean showReport) {
        this.showReport = showReport;
    }

    public List<String> getAnalyzedTestpathMd5() {
        return analyzedTestpathMd5;
    }

    public void setAnalyzedTestpathMd5(List<String> analyzedTestpathMd5) {
        this.analyzedTestpathMd5 = analyzedTestpathMd5;
    }

    public List<String> getGeneratedTestcases() {
        return generatedTestcases;
    }

    public void setGeneratedTestcases(List<String> generatedTestcases) {
        this.generatedTestcases = generatedTestcases;
    }

    public List<TestCase> getTestCases() {
        return testCases;
    }

    public void setTestCases(List<TestCase> testCases) {
        this.testCases = testCases;
    }

    public void setShouldRunParallel(boolean shouldRunParallel) {
        this.shouldRunParallel = shouldRunParallel;
    }

    public boolean isShouldRunParallel() {
        return shouldRunParallel;
    }
}
