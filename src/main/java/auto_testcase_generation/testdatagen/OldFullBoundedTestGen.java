package auto_testcase_generation.testdatagen;


import auto_testcase_generation.cfg.CFGGenerationforSubConditionCoverage;
import auto_testcase_generation.cfg.ICFG;
import auto_testcase_generation.cfg.object.AbstractConditionLoopCfgNode;
import auto_testcase_generation.cfg.object.ConditionCfgNode;
import auto_testcase_generation.cfg.object.EndFlagCfgNode;
import auto_testcase_generation.cfg.object.ICfgNode;
import auto_testcase_generation.cfg.testpath.*;
import auto_testcase_generation.constraints.checker.RelatedConstraintsChecker;
import auto_testcase_generation.testdatagen.se.ISymbolicExecution;
import auto_testcase_generation.testdatagen.se.Parameters;
import auto_testcase_generation.testdatagen.se.PathConstraint;
import auto_testcase_generation.testdatagen.se.SymbolicExecution;
import auto_testcase_generation.testdatagen.se.solver.RunZ3OnCMD;
import auto_testcase_generation.testdatagen.se.solver.SmtLibGeneration;
import auto_testcase_generation.testdatagen.se.solver.solutionparser.Z3SolutionParser;
import com.dse.config.AkaConfig;
import com.dse.config.WorkspaceConfig;
import com.dse.guifx_v3.controllers.TestCasesNavigatorController;
import com.dse.guifx_v3.helps.CacheHelper;
import com.dse.guifx_v3.helps.UIController;
import com.dse.guifx_v3.helps.UILogger;
import com.dse.guifx_v3.objects.TestCasesTreeItem;
import com.dse.logger.AkaLogger;
import com.dse.parser.object.*;
import com.dse.search.Search2;
import com.dse.testcase_execution.TestcaseExecution;
import com.dse.testcase_manager.ITestCase;
import com.dse.testcase_manager.TestCase;
import com.dse.testcase_manager.TestCaseManager;
import com.dse.testcase_manager.minimize.GreedyMinimizer;
import com.dse.testcase_manager.minimize.ITestCaseMinimizer;
import com.dse.testcase_manager.minimize.Scope;
import com.dse.testdata.object.IDataNode;
import com.dse.testdata.object.RootDataNode;
import com.dse.thread.task.AutoGeneratedTestCaseExecTask;
import com.dse.util.SpecialCharacter;
import com.dse.util.Utils;
import javafx.application.Platform;
import org.apache.commons.math3.random.RandomDataGenerator;

import java.io.File;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Deprecated
public class OldFullBoundedTestGen extends AbstractAutomatedTestdataGeneration {
    private final static AkaLogger logger = AkaLogger.get(OldFullBoundedTestGen.class);
    /**
     * Represent control flow graph
     */
    private ICFG cfg;
    private int maxIterationsforEachLoop;
    private FullTestpaths possibleTestpaths = new FullTestpaths();
    private List<IVariableNode> variables;
    private boolean shouldRunParallel = true;

    public OldFullBoundedTestGen(ICommonFunctionNode fn, String coverageType) {
        super(fn);
        this.coverageType = coverageType;
        /*
         * There is no previous test case, just need to construct a cfg
         */
        try {
            if (fn instanceof MacroFunctionNode) {
                IFunctionNode tmpFunctionNode = ((MacroFunctionNode) fn).getCorrespondingFunctionNode();
                cfg = new CFGGenerationforSubConditionCoverage(tmpFunctionNode).generateCFG();
                cfg.setFunctionNode(tmpFunctionNode);
            } else if (fn instanceof AbstractFunctionNode) {
                cfg = new CFGGenerationforSubConditionCoverage((IFunctionNode) fn).generateCFG();
                cfg.setFunctionNode((IFunctionNode) fn);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        this.maxIterationsforEachLoop = 1;
        this.cfg.resetVisitedStateOfNodes();
        this.cfg.setIdforAllNodes();
        this.variables = fn.getArguments();

        TestCasesTreeItem treeItem = CacheHelper.getFunctionToTreeItemMap().get(fn);
        if (CacheHelper.getTreeItemToListTestCasesMap().get(treeItem) != null)
            CacheHelper.getTreeItemToListTestCasesMap().get(treeItem).clear();

        testCases = TestCaseManager.getTestCasesByFunction(this.fn);
    }

    public static void main(String[] args) throws Exception {
    }

    public void generateTestdata(ICommonFunctionNode fn) throws Exception {
        List<TestCase> oldTestcases = new ArrayList<>(testCases);

        for (int iteration = 0; iteration < maxIterationsforEachLoop; iteration++) {

            Set<String> testCasesInString = new HashSet<String>();

            this.generateTestpaths(testCasesInString);

            ExecutorService es = Executors.newFixedThreadPool(5);
            List<Callable<String>> tasks = new ArrayList<>();
            for (String testCaseItem : testCasesInString) {
                StringHandler task = new StringHandler(testCaseItem, iteration);
                tasks.add(task);
            }
            es.invokeAll(tasks);
            logger.debug("Test case: " + this.testCases);
        }

        for (int i = testCases.size() - 1; i >= 0; i--) {
            if (oldTestcases.contains(testCases.get(i))) {
                testCases.remove(i);
            }
        }

        List<TestCase> origin = new ArrayList<>(testCases);
        ITestCaseMinimizer minimizer = new GreedyMinimizer();
        minimizer.clean(origin, Scope.SOURCE);

        onGenerateSuccess(showReport);
    }

    public void generateTestpaths(Set<String> testCases) {

        FullTestpaths testpaths_ = new FullTestpaths();

        ICfgNode beginNode = cfg.getBeginNode();
        FullTestpath initialTestpath = new FullTestpath();
        initialTestpath.setFunctionNode(cfg.getFunctionNode());
        try {
            traverseCFG(beginNode, initialTestpath, testpaths_, testCases);
        } catch (Exception e) {
            e.printStackTrace();
        }

        for (ITestpathInCFG tp : testpaths_) {
            tp.setFunctionNode(cfg.getFunctionNode());
        }

        possibleTestpaths = testpaths_;

    }

    private void traverseCFG(ICfgNode stm, FullTestpath tp, FullTestpaths testpaths, Set<String> testCases) throws Exception {

        tp.add(stm);

        if (stm instanceof EndFlagCfgNode) {
            testpaths.add((FullTestpath) tp.clone());
            tp.remove(tp.size() - 1);
        } else {
            ICfgNode trueNode = stm.getTrueNode();
            ICfgNode falseNode = stm.getFalseNode();

            if (stm instanceof ConditionCfgNode) {

                if (stm instanceof AbstractConditionLoopCfgNode) {

                    int currentIterations = tp.count(trueNode);
                    if (currentIterations < maxIterationsforEachLoop) {

                        traverseCFG(falseNode, tp, testpaths, testCases);
                        traverseCFG(trueNode, tp, testpaths, testCases);
                    } else {
                        traverseCFG(falseNode, tp, testpaths, testCases);
                    }
                } else {

                    Random rand = new Random();
                    for (int i = -1; i < 2; i++) {
                        FullTestpath tp1 = (FullTestpath) tp.clone();
                        ConditionCfgNode stm1 = (ConditionCfgNode) stm.clone();

                        tp1.remove(tp.lastIndexOf(stm));
                        stm1.setContent(stm1.getContent().replaceAll("<=|>=|<|>|!=", "=="));
                        stm1.setAst(Utils.convertToIAST(stm1.getContent() + "+" + i));
                        tp1.add(stm1);
                        tp1.add(trueNode);

                        String result = this.haveSolution(tp1, true);
                        for (IVariableNode variable : this.variables) {
                            if (!result.contains(variable.toString()) && !result.equals(IStaticSolutionGeneration.NO_SOLUTION)) {
                                result += variable.toString() + "=" + rand.nextInt(100) + ";";
                            }
                        }
                        if (!result.equals(IStaticSolutionGeneration.NO_SOLUTION)) {
                            testCases.add(result.replaceAll(";;", ";"));
                        }


                    }


                    traverseCFG(falseNode, tp, testpaths, testCases);

                    traverseCFG(trueNode, tp, testpaths, testCases);

                }
            } else {
                traverseCFG(trueNode, tp, testpaths, testCases);
            }

            tp.remove(tp.size() - 1);
        }
    }

    protected String haveSolution(FullTestpath tp, boolean finalConditionType) throws Exception {
        IPartialTestpath tp1 = createPartialTestpath(tp, finalConditionType);

        String solution = solveTestpath(cfg.getFunctionNode(), tp1);
        return solution;
//	if (!solution.equals(IStaticSolutionGeneration.NO_SOLUTION))
//		return true;
//	else {
//		return false;
//	}
    }

    protected IPartialTestpath createPartialTestpath(FullTestpath fullTp, boolean finalConditionType) {
        IPartialTestpath partialTp = new PartialTestpath();
        for (ICfgNode node : fullTp.getAllCfgNodes()) {
            partialTp.getAllCfgNodes().add(node);
        }

        partialTp.setFinalConditionType(finalConditionType);
        return partialTp;
    }

    protected String solveTestpath(IFunctionNode fn, ITestpathInCFG testpath) throws Exception {
        /*
         * Get the passing variables of the given fn
         */
        Parameters parameters = new Parameters();
        parameters.addAll(fn.getArguments());
        parameters.addAll(fn.getReducedExternalVariables());

        /*
         * Get the corresponding path constraints of the test path
         */
        ISymbolicExecution se = new SymbolicExecution(testpath, parameters, fn);

        // fast checking
        RelatedConstraintsChecker relatedConstraintsChecker = new RelatedConstraintsChecker(
                se.getConstraints().getNormalConstraints(), fn);
        //	boolean isRelated = relatedConstraintsChecker.check();
        //
        if (true) {
            if (se.getConstraints().getNormalConstraints().size()
                    + se.getConstraints().getNullorNotNullConstraints().size() > 0) {


                // generate smt-lib2
                SmtLibGeneration smt = new SmtLibGeneration(parameters, se.getNormalizedPathConstraints(), fn, se.getNewVariables());
                smt.generate();
                logger.debug("SMT-LIB file:\n" + smt.getSmtLibContent());
                String constraintFile = new WorkspaceConfig().fromJson().getConstraintFolder()
                        + File.separator + new RandomDataGenerator().nextInt(0, 99999) + ".smt2";
                logger.debug("constraintFile: " + constraintFile);
                Utils.writeContentToFile(smt.getSmtLibContent(), constraintFile);

                // solve
                logger.debug("Calling solver z3");
                String z3Path = new AkaConfig().fromJson().getZ3Path();
                if (!new File(z3Path).exists())
                    throw new Exception("Z3 path " + " does not exist");

                RunZ3OnCMD z3Runner = new RunZ3OnCMD(z3Path, constraintFile);
                z3Runner.execute();

                logger.debug("Original solution:\n" + z3Runner.getSolution());
                String staticSolution = new Z3SolutionParser().getSolution(z3Runner.getSolution());

                if (staticSolution.equals(IStaticSolutionGeneration.NO_SOLUTION)) {
                    return IStaticSolutionGeneration.NO_SOLUTION;
                } else {
                    if (se.getConstraints().getNullorNotNullConstraints().size() > 0) {
                        for (PathConstraint nullConstraint : (List<PathConstraint>) se.getConstraints().getNullorNotNullConstraints()) {
                            staticSolution += nullConstraint + SpecialCharacter.END_OF_STATEMENT;
                        }
                    }
                    if (se.getConstraints().getNullorNotNullConstraints().size() > 0) {
                        return staticSolution + "; " + se.getConstraints().getNullorNotNullConstraints();
                    } else {
                        return staticSolution + ";";
                    }
                }
            } else {
                return IStaticSolutionGeneration.NO_SOLUTION;
            }
        } else {
            return IStaticSolutionGeneration.EVERY_SOLUTION;
        }
    }

    public ICFG getCfg() {
        return cfg;
    }

    public void setCfg(ICFG cfg) {
        this.cfg = cfg;
    }

    public int getMaxIterationsforEachLoop() {
        return maxIterationsforEachLoop;
    }

    public void setMaxIterationsforEachLoop(int maxIterationsforEachLoop) {
        this.maxIterationsforEachLoop = maxIterationsforEachLoop;
    }

    public FullTestpaths getPossibleTestpaths() {
        return possibleTestpaths;
    }

    protected synchronized TestCase createTestcase(int iteration, ICommonFunctionNode functionNode) {
        TestCase testCase = null;
        // create a new test case at each iteration
        String nameofTestcase = TestCaseManager.generateContinuousNameOfTestcase(functionNode.getSimpleName() + ITestCase.POSTFIX_TESTCASE_BY_BOUNDARY);

        testCase = TestCaseManager.createTestCase(nameofTestcase, functionNode);

        if (testCase != null) {
            TestCaseManager.getNameToBasicTestCaseMap().put(testCase.getName(), testCase);
            testCase.setCreationDateTime(LocalDateTime.now());

            String testpathFileName = nameofTestcase + "__iter__" + iteration; // to avoid the misunderstanding between system separator and its name
            String testpathFile = new WorkspaceConfig().fromJson().getTestpathDirectory() + File.separator + testpathFileName + ".tp";
            testCase.setTestPathFile(testpathFile);
        }
        return testCase;
    }

    protected void execute(TestCase testCase, List<AutoGeneratedTestCaseExecTask> execTasks) {

        try {
            TestcaseExecution executor = new TestcaseExecution();
            executor.setFunction(fn);
            executor.setMode(TestcaseExecution.IN_AUTOMATED_TESTDATA_GENERATION_MODE);
            AutoGeneratedTestCaseExecTask task = new AutoGeneratedTestCaseExecTask(executor, testCase, execTasks);
            task.setShowReport(showReport);
            UILogger.getUiLogger().info("Executing test case: " + testCase);
            task.run();
        } catch (Exception e) {
            e.printStackTrace();
            testCases.remove(testCase);
            testCase.setStatus(TestCase.STATUS_FAILED);
            logger.debug("[" + Thread.currentThread().getName() + "] " + "There is a problem with the current test case. Move to the next iteration.");
        }

    }

    private class StringHandler implements Callable<String> {
        private final String testCaseInString;
        private final int iteration;

        public StringHandler(String testCase, int iteration) {
            this.testCaseInString = testCase;
            this.iteration = iteration;
        }

        @Override
        public String call() throws Exception {
            handleString();
            return null;
        }

        private void handleString() throws Exception {
            ValueToTestcaseConverter_UnknownSize converter = new ValueToTestcaseConverter_UnknownSize(testCaseInString);
            List<RandomValue> randomValues = converter.convert();
            logger.debug("Rand: " + randomValues);

            TestCase testCase = createTestcase(iteration, fn);
            RootDataNode root = testCase.getRootDataNode();
            IDataNode sutRoot = Search2.findSubprogramUnderTest(root);
            recursiveExpandUutBranch(sutRoot, randomValues, testCase);
            //add testCase
            testCase.updateToTestCasesNavigatorTree();
            Platform.runLater(() -> TestCasesNavigatorController.getInstance().refreshNavigatorTree());
            testCases.add(testCase);
            //execute
            TestCasesNavigatorController.getInstance().refreshNavigatorTreeFromAnotherThread();
            execute(testCase, execTasks);
        }
    }


}
