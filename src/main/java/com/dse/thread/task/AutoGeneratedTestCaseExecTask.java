package com.dse.thread.task;

import com.dse.config.IFunctionConfig;
import com.dse.coverage.CoverageManager;
import com.dse.coverage.CoverageDataObject;
import com.dse.environment.Environment;
import com.dse.environment.object.EnviroCoverageTypeNode;
import com.dse.guifx_v3.controllers.TestCasesExecutionTabController;
import com.dse.guifx_v3.controllers.TestCasesNavigatorController;
import com.dse.guifx_v3.helps.CacheHelper;
import com.dse.guifx_v3.helps.TCExecutionDetailLogger;
import com.dse.guifx_v3.objects.TestCaseExecutionDataNode;
import com.dse.guifx_v3.objects.TestCasesTreeItem;
import com.dse.testcase_manager.minimize.GreedyMinimizer;
import com.dse.testcase_manager.minimize.ITestCaseMinimizer;
import com.dse.testcase_manager.minimize.Scope;
import com.dse.parser.object.ICommonFunctionNode;
import com.dse.testcase_execution.TestcaseExecution;
import com.dse.testcase_manager.ITestCase;
import com.dse.testcase_manager.TestCase;
import com.dse.testcase_manager.TestCaseManager;
import com.dse.thread.AbstractAkaTask;
import com.dse.logger.AkaLogger;
import com.dse.util.Utils;
import javafx.application.Platform;
import javafx.collections.ObservableList;

import java.util.ArrayList;
import java.util.List;

public class AutoGeneratedTestCaseExecTask extends AbstractAkaTask<TestCase> {

    private final static AkaLogger logger = AkaLogger.get(AutoGeneratedTestCaseExecTask.class);
    private final TestCase testCase;
    private ICommonFunctionNode functionNode;
    private TestcaseExecution executor;
    private List<AutoGeneratedTestCaseExecTask> execTasks;
    private boolean showReport = false;

    public AutoGeneratedTestCaseExecTask(TestcaseExecution executor, TestCase testCase,
                                         List<AutoGeneratedTestCaseExecTask> execTasks) {
        this.testCase = testCase;
        this.functionNode = testCase.getRootDataNode().getFunctionNode();
        this.executor = executor;
        this.execTasks = execTasks;
    }

    public void setShowReport(boolean showReport) {
        this.showReport = showReport;
    }

    public TestCase getTestCase() {
        return testCase;
    }

    @Override
    protected TestCase call() throws Exception {
        try {
            if (testCase == null) {
                return null;
            }

            testCase.setStatus(TestCase.STATUS_EXECUTING);
            refreshNavigatorTree();

            String coverage = Environment.getInstance().getTypeofCoverage();

            // add and initialize corresponding TestCaseExecutionDataNode
            TCExecutionDetailLogger.addTestCase(functionNode, testCase);
            TestCaseExecutionDataNode executionDataNode = TCExecutionDetailLogger.getExecutionDataNodeByTestCase(testCase);
            if (executionDataNode == null)
                return null;
            TCExecutionDetailLogger.logDetailOfTestCase(testCase, "Name: " + testCase.getName());
            String value = testCase.getRootDataNode().getRoot().getInputForGoogleTest(false);
            TCExecutionDetailLogger.logDetailOfTestCase(testCase, "Value: " + value);
            executionDataNode.setValue(value);

            // Execute random values
            executor.setTestCase(testCase);
            executor.execute();
            TestCaseManager.exportBasicTestCaseToFile(testCase);

            if (testCase.getStatus().equals(TestCase.STATUS_SUCCESS)
                    || testCase.getStatus().equals(ITestCase.STATUS_RUNTIME_ERR)) {
                // save test case to file
                testCase.setPathDefault();
                logger.debug("Save the testcase " + testCase.getName() + " to file " + testCase.getPath());

                // export highlighted source code and coverage to file
                CoverageManager.exportCoveragesOfTestCaseToFile(testCase, coverage);

                // read coverage information from file to display on GUI
                List<TestCase> testcases = new ArrayList<>();
                testcases.add(testCase);

                switch (coverage) {
                    case EnviroCoverageTypeNode.STATEMENT:
                    case EnviroCoverageTypeNode.BRANCH:
                    case EnviroCoverageTypeNode.BASIS_PATH:
                    case EnviroCoverageTypeNode.MCDC: {
                        CoverageDataObject coverageData = CoverageManager
                                .getCoverageOfMultiTestCaseAtSourcecodeFileLevel(testcases, coverage);
                        double cov = Utils.round(coverageData.getVisited() * 1.0f / coverageData.getTotal() * 100, 4);
                        String msg = coverage + " cov: " + cov + "%";
                        TCExecutionDetailLogger.logDetailOfTestCase(testCase, msg);
                        executionDataNode.setCoverage(msg);
                        break;
                    }
                    case EnviroCoverageTypeNode.STATEMENT_AND_BRANCH: {
                        String msg = "";
                        // stm cov
                        CoverageDataObject stmCovData = CoverageManager
                                .getCoverageOfMultiTestCaseAtSourcecodeFileLevel(testcases, EnviroCoverageTypeNode.STATEMENT);
                        double stmCov = Utils.round(stmCovData.getVisited() * 1.0f / stmCovData.getTotal() * 100, 4);
                        msg = EnviroCoverageTypeNode.STATEMENT + " cov: " + stmCov + "%; ";

                        // branch cov
                        CoverageDataObject branchCovData = CoverageManager
                                .getCoverageOfMultiTestCaseAtSourcecodeFileLevel(testcases, EnviroCoverageTypeNode.BRANCH);
                        double branchCov = Utils.round(branchCovData.getVisited() * 1.0f / branchCovData.getTotal() * 100, 4);
                        msg += EnviroCoverageTypeNode.BRANCH + " cov: " + branchCov + "%";

                        TCExecutionDetailLogger.logDetailOfTestCase(testCase, msg);
                        executionDataNode.setCoverage(msg);
                        break;
                    }
                    case EnviroCoverageTypeNode.STATEMENT_AND_MCDC: {
                        String msg = "";
                        // stm coverage
                        CoverageDataObject stmCovData = CoverageManager
                                .getCoverageOfMultiTestCaseAtSourcecodeFileLevel(testcases, EnviroCoverageTypeNode.STATEMENT);
                        double stmCov = Utils.round(stmCovData.getVisited() * 1.0f / stmCovData.getTotal() * 100, 4);
                        msg = EnviroCoverageTypeNode.STATEMENT + " cov: " + stmCov + "%; ";

                        // mcdc coverage
                        CoverageDataObject branchCovData = CoverageManager
                                .getCoverageOfMultiTestCaseAtSourcecodeFileLevel(testcases, EnviroCoverageTypeNode.MCDC);
                        double mcdcCov = Utils.round(branchCovData.getVisited() * 1.0f / branchCovData.getTotal() * 100, 4);
                        msg += EnviroCoverageTypeNode.MCDC + " cov: " + mcdcCov + "%";

                        TCExecutionDetailLogger.logDetailOfTestCase(testCase, msg);
                        executionDataNode.setCoverage(msg);
                        break;
                    }
                }

                // display on Execution View
                TestCasesExecutionTabController testCasesExecutionTabController = TCExecutionDetailLogger.getTCExecTabControllerByFunction(functionNode);
                if (testCasesExecutionTabController != null) {
                    ObservableList<TestCaseExecutionDataNode> data = testCasesExecutionTabController.getData();
                    executionDataNode.setId(data.size());
                    data.add(executionDataNode);
                }

                // update testcase on disk
                TestCaseManager.exportBasicTestCaseToFile(testCase);
                // export coverage of testcase to file
                CoverageManager.exportCoveragesOfTestCaseToFile(testCase, Environment.getInstance().getTypeofCoverage());
                // save to tst file and navigator tree
                refreshNavigatorTree();
            }
        } catch (Exception e) {
            e.printStackTrace();
            testCase.setStatus(TestCase.STATUS_FAILED);
            logger.error("Can not execute test case " + testCase.getName());
        } finally {
            execTasks.remove(this);
//            String strategy = testCase.getFunctionNode().getFunctionConfig().getTestdataGenStrategy();
//            if (strategy.equals(IFunctionConfig.TEST_DATA_GENERATION_STRATEGIES.RANDOM)) {
//                // stop condition for RANDOM test data generation strategy
//                TestCasesTreeItem treeItem = CacheHelper.getFunctionToTreeItemMap().get(testCase.getFunctionNode());
//                // get test cases that have just be generated
//                List<TestCase> testCases = CacheHelper.getTreeItemToListTestCasesMap().get(treeItem);
//
//                if (isExecuteAllDone(testCases)) { // test data RANDOM auto generating stage is done
//                    try {
//                        // clean unnecessary test cases
//                        ITestCaseMinimizer minimizer = new GreedyMinimizer();
//                        minimizer.clean(testCases, Scope.SOURCE);
//
//                        // view coverage of generated set of test cases
////                        if (showReport) {
////                            UIController.viewCoverageOfMultipleTestcasesFromAnotherThread(functionNode.getName(), testCases);
////                        }
//
//                    } catch (Exception ex) {
//                        ex.printStackTrace();
//                    }
//                }
//            }
        }

        return testCase;
    }

    private boolean isExecuteAllDone(List<TestCase> testCases) {
        long generated = testCases.size();
        long maxIteration = getFunctionNode().getFunctionConfig().getTheMaximumNumberOfIterations();

        return generated >= maxIteration
                && execTasks.isEmpty()
                && testCases.stream()
                    .allMatch(tc -> tc.getStatus().equals(ITestCase.STATUS_FAILED)
                            || tc.getStatus().equals(ITestCase.STATUS_RUNTIME_ERR)
                            || tc.getStatus().equals(ITestCase.STATUS_SUCCESS));
    }

    private void refreshNavigatorTree() {
        Platform.runLater(() -> TestCasesNavigatorController.getInstance().refreshNavigatorTree());
    }

    public ICommonFunctionNode getFunctionNode() {
        return functionNode;
    }

    public void setFunctionNode(ICommonFunctionNode functionNode) {
        this.functionNode = functionNode;
    }
}
